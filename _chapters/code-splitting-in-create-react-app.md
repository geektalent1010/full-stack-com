---
layout: post
title: Code Splitting in Create React App
description: Tutorial on code splitting in React.js using Create React App and React Router v4. Setting up routes to load asynchronously using the dynamic import() in Create React App 1.0.
date: 2017-02-14 12:00:00
code: frontend
comments_id: 71
---

This chapter is an extra step that can help speed up the initial load time of your React app. It is not a required step to complete this guide. But feel free to follow along if you are curious about what Code Splitting is and how it can help larger React.js apps.

While working on React.js single page apps, there is a tendency for apps to grow quite large. A section of the app (or route) might import a large number of components that are not necessary when it first loads. This hurts the initial load time of our app.

You might have noticed a `bundle.js` file that is generated by Create React App while we are building our app. This contains all the JavaScript our app needs. But if a user is simply loading the login page to sign in; it doesn't make sense that we load the rest of the app with it. This isn't a concern early on when our app is quite small but it becomes an issue down the road. To address this, Create React App has a very simple built-in way to split up our code. This feature unsurprisingly, is called Code Splitting.

### Code Splitting

Create React App (from 1.0 onwards) allows us to dynamically import parts of our app using the `import()` proposal. You can read more about it [here](https://facebook.github.io/react/blog/2017/05/18/whats-new-in-create-react-app.html#code-splitting-with-dynamic-import).

While, the dynamic `import()` can be used for any component in our React app; it works really well with React Router. Since, React Router is figuring out which component to load based on the path; it would make sense that we dynamically import those components only when we navigate to them.

### Code Splitting and React Router v4

The usual structure used by React Router to set up routing for your app looks something like this.

``` coffee
<Switch>
  <Route path="/" exact component={Home} />
  <Route path="/posts/:id" exact component={Posts} />

  { /* Rest of our routes ...  */ }

  <Route component={NotFound} />
</Switch>
```

The top portion of the `Switch` matches the specific routes and we end by adding a Route that handles any failed matches. If you recall, we do something very similar in our Notes app. In our `src/Routes.js`, our `Switch` block looks like the following.

``` coffee
<Switch>
  <AppliedRoute path="/" exact component={Home} props={childProps} />
  <UnauthenticatedRoute path="/login" exact component={Login} props={childProps} />
  <UnauthenticatedRoute path="/signup" exact component={Signup} props={childProps} />
  <AuthenticatedRoute path="/notes/new" exact component={NewNote} props={childProps} />
  <AuthenticatedRoute path="/notes/:id" exact component={Notes} props={childProps} />
  { /* Finally, catch all unmatched routes */ }
  <Route component={NotFound} />
</Switch>
```

The `AppliedRoute` simply applies the `props` attribute to the `component`. And the `UnauthenticatedRoute` and `AuthenticatedRoute` components handle checking the auth details before proceeding.

However, `src/Routes.js` imports all of the components in the route statically at the top. This means, that all these components are loaded regardless of which route is matched. To implement Code Splittig here we are going to want to only load the component that responds to the matched route.

### Create an Async Component

To do this we are going to dynamically import the required component.

<img class="code-marker" src="{{ site.url }}/assets/s.png" />Add the following to `src/components/AsyncComponent.js`.

``` coffee
import React, { Component } from 'react';

export default function asyncComponent(componentName) {

  class AsyncComponent extends Component {

    constructor(props) {
      super(props);

      this.state = {
        component: null,
      };
    }

    async componentDidMount() {
      const { default: component } = await import(`../containers/${componentName}`);

      this.setState({
        component: component
      });
    }

    render() {
      const C = this.state.component;

      return C
        ? <C {...this.props} />
        : null;
    }

  }

  return AsyncComponent;
}
```

We are doing a few things here:

1. The `asyncComponent` function takes a string (`componentName`) that is the component we are trying to load in our route.
2. On `componentDidMount` we use the dynamic `import()` to load the container with the given name. In this case we are assuming the component we are trying to load is in the `containers/` directory. If this is not the case for your project, you can pass in the full path to this function.
3. Finally, we conditionally render the component if it has completed loading. If not we simply render `null`. But instead of rendering null, you could render a loading spinner. This would give the user some feedback while a part of your app is still loading.

### Use the Async Component

Now let's use this component in our routes. Instead of passing in the statically imported component to our routes like so.

``` coffee
<Route path="/" exact component={Home} />
```

We are going to wrap it up with our `asyncComponent` method.

``` coffee
<Route path="/" exact component={asyncComponent('Home')} />
```

Notice, that we are passing in the `Home` component as a string. And so we won't need to import it here.

<img class="code-marker" src="{{ site.url }}/assets/s.png" />Your `src/Routes.js` should now look like this.

``` coffee
import React from 'react';
import { Route, Switch } from 'react-router-dom';
import asyncComponent from './components/AsyncComponent';
import AppliedRoute from './components/AppliedRoute';
import AuthenticatedRoute from './components/AuthenticatedRoute';
import UnauthenticatedRoute from './components/UnauthenticatedRoute';

export default ({ childProps }) => (
  <Switch>
    <AppliedRoute path="/" exact component={asyncComponent('Home')} props={childProps} />
    <UnauthenticatedRoute path="/login" exact component={asyncComponent('Login')} props={childProps} />
    <UnauthenticatedRoute path="/signup" exact component={asyncComponent('Signup')} props={childProps} />
    <AuthenticatedRoute path="/notes/new" exact component={asyncComponent('NewNote')} props={childProps} />
    <AuthenticatedRoute path="/notes/:id" exact component={asyncComponent('Notes')} props={childProps} />
    { /* Finally, catch all unmatched routes */ }
    <Route component={asyncComponent('NotFound')} />
  </Switch>
);
```

Now if you build your app using `npm run build`; you'll see the code splitting in action.

![Create React App Code Splitting build screenshot]({{ site.url }}/assets/create-react-app-code-splitting-build.png)

Each of those `.chunk.js` files are the different dynamic `import()` calls that we have.  Of course, our app is quite small and the various parts that are split up are not significant at all. However, if the page that we use to edit our note included a rich text editor; you can imagine how that would grow in size. And it would unfortunately affect the initial load time of our app.

Now if we deploy our app using `npm run deploy`; you can see the browser load the different chunks on-demand as we browse around.

![Create React App loading Code Splitting screenshot]({{ site.url }}/assets/create-react-app-loading-code-splitting.png)

That's it! With just a few simple changes our app is completely set up to use the code splitting feature that Create React App has.
